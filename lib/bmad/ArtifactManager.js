/**
 * BMAD Artifact Manager
 * 
 * Manages the lifecycle of documents and other artifacts generated by agents.
 * This system is a key part of Phase 2, ensuring that the document-driven
 * workflow is correctly implemented.
 * 
 * Key Features:
 * - Handles saving and loading of generated documents.
 * - Enforces agent permissions for document access (TODO).
 * - Manages artifact storage paths based on core-config.yaml.
 * - Prepares artifacts for document sharding (Phase 3).
 */

const path = require('path');
import logger from '../utils/logger.js';
import { FileManager } from './AgentExecutor/FileManager.js';
const fileManager = new FileManager();

class ArtifactManager {
  constructor(configurationManager, agentActivationEngine) {
    this.configManager = configurationManager;
    this.agentEngine = agentActivationEngine;
    this.artifacts = new Map(); // In-memory store for artifacts during a workflow
    this.initialized = false;
  }

  async initialize(configurationManager, agentActivationEngine) {
    this.configManager = configurationManager;
    this.agentEngine = agentActivationEngine;
    
    // Initialize file manager for S3/local storage
    await fileManager.initialize();
    
    this.initialized = true;
    logger.info("ArtifactManager initialized with S3 support");
  }

  /**
   * Save a document using S3/cloud storage.
   * @param {string} documentContent - The content of the document.
   * @param {string} documentType - The type of document (e.g., 'prd', 'architecture').
   * @param {string} activeAgentId - The ID of the agent saving the document.
   * @param {object} context - Workflow context (userId, workflowId, team, etc.)
   * @returns {object} The saved document info with S3 URL.
   */
  async saveDocument(documentContent, documentType, activeAgentId, context = {}) {
    if (!this.agentEngine.canAgentEditSection(activeAgentId, documentType)) {
      logger.warn(`[ARTIFACT] Agent ${activeAgentId} does not have permission to save document type: ${documentType}`);
      throw new Error(`Agent ${activeAgentId} does not have permission to save document type: ${documentType}`);
    }

    const filename = `${documentType}.md`;
    logger.info(`üìÑ [ARTIFACT] Saving document of type '${documentType}' via S3`);

    try {
      // Determine file context based on workflow type
      let fileContext;
      const { userId, workflowId, team, chatSessionId } = context;

      if (chatSessionId) {
        // Agent Chat context
        fileContext = {
          userId,
          agentId: activeAgentId,
          filename,
          chatContext: { chatSessionId }
        };
      } else if (team && workflowId) {
        // Agent Teams context  
        fileContext = {
          userId,
          agentId: activeAgentId,
          filename,
          workflowContext: { team, workflowId }
        };
      } else {
        logger.error(`[ARTIFACT] Invalid context provided:`, context);
        throw new Error('Either chatSessionId or (team + workflowId) must be provided');
      }

      // Save document using FileManager (S3 or local)
      const result = await fileManager.writeAgentFile(fileContext, documentContent);
      
      const artifact = { 
        type: documentType, 
        path: result.path,
        url: result.url, // S3 URL for direct access
        content: documentContent,
        createdBy: activeAgentId,
        createdAt: new Date().toISOString(),
        storage: result.storage, // 's3' or 'local'
        context: fileContext
      };
      this.artifacts.set(documentType, artifact);

      logger.info(`‚úÖ [ARTIFACT] Successfully saved document via ${result.storage}: ${result.path}`);
      return {
        path: result.path,
        url: result.url,
        artifact,
        storage: result.storage
      };

    } catch (error) {
      logger.error(`‚ùå [ARTIFACT] Failed to save document:`, error.message);
      throw new Error(`Failed to save document: ${error.message}`);
    }
  }

  /**
   * Load a document from S3/cloud storage.
   * @param {string} documentType - The type of document to load.
   * @param {string} activeAgentId - The ID of the agent loading the document.
   * @param {object} context - Workflow context (userId, workflowId, team, etc.)
   * @returns {Object} The loaded artifact object.
   */
  async loadDocument(documentType, activeAgentId, context = {}) {
    if (!this.agentEngine.canAgentViewSection(activeAgentId, documentType)) {
      logger.warn(`[ARTIFACT] Agent ${activeAgentId} does not have permission to load document type: ${documentType}`);
      throw new Error(`Agent ${activeAgentId} does not have permission to load document type: ${documentType}`);
    }

    // Check in-memory cache first
    if (this.artifacts.has(documentType)) {
      return this.artifacts.get(documentType);
    }

    const filename = `${documentType}.md`;
    logger.info(`üìÑ [ARTIFACT] Loading document of type '${documentType}' via S3`);

    try {
      // Determine file context based on workflow type
      let fileContext;
      const { userId, workflowId, team, chatSessionId } = context;

      if (chatSessionId) {
        // Agent Chat context
        fileContext = {
          userId,
          agentId: activeAgentId,
          filename,
          chatContext: { chatSessionId }
        };
      } else if (team && workflowId) {
        // Agent Teams context  
        fileContext = {
          userId,
          agentId: activeAgentId,
          filename,
          workflowContext: { team, workflowId }
        };
      } else {
        logger.error(`[ARTIFACT] Invalid context provided for loading:`, context);
        throw new Error('Either chatSessionId or (team + workflowId) must be provided');
      }

      // Load document using FileManager
      const content = await fileManager.readAgentFile(fileContext);
      
      const artifact = { 
        type: documentType, 
        path: fileContext.key || fileContext.localPath,
        content: content,
        loadedBy: activeAgentId,
        loadedAt: new Date().toISOString(),
        context: fileContext
      };
      this.artifacts.set(documentType, artifact);

      logger.info(`‚úÖ [ARTIFACT] Successfully loaded document from storage`);
      return artifact;

    } catch (error) {
      logger.error(`‚ùå [ARTIFACT] Failed to load document:`, error.message);
      // It might not exist yet, which is not always a critical error.
      return null;
    }
  }

  /**
   * Get the filesystem path for a given document type.
   * @param {string} documentType - The type of document.
   * @returns {string} The absolute path for the document.
   */
  getDocumentPath(documentType) {
    let relativePath;
    switch (documentType) {
      case 'prd':
        relativePath = this.configManager.get('prd.prdFile');
        break;
      case 'architecture':
        relativePath = this.configManager.get('architecture.architectureFile');
        break;
      // Add other document types here as needed
      default:
        // For stories or other dynamic artifacts
        const storyLocation = this.configManager.get('devStoryLocation');
        relativePath = path.join(storyLocation, `${documentType}.md`);
        break;
    }

    if (!relativePath) {
      throw new Error(`No path configured for document type: ${documentType}`);
    }

    return this.configManager.getAbsolutePath(relativePath);
  }

  async getWorkflowArtifacts(workflowId) {
    // For now, we'll just return the in-memory artifacts.
    // In the future, this could be expanded to retrieve artifacts from a database or other storage.
    return Array.from(this.artifacts.values());
  }

  async saveWorkflowArtifacts(workflowId, artifacts) {
    // For now, just return the artifacts as they're already saved during workflow execution
    // In the future, this could persist artifacts to a database or permanent storage
    logger.info(`üì¶ [ARTIFACT] Saving ${artifacts.length} workflow artifacts for workflow ${workflowId}`);
    return artifacts;
  }

  async getArtifactContent(workflowId, filename) {
    const artifact = Array.from(this.artifacts.values()).find(a => a.path.endsWith(filename));
    if (artifact) {
      return artifact.content;
    }
    return null;
  }

  /**
   * Get an artifact from the in-memory store.
   * @param {string} artifactType - The type of artifact to retrieve.
   * @returns {Object | undefined} The artifact object.
   */
  getArtifact(artifactType) {
    return this.artifacts.get(artifactType);
  }

  /**
   * Clear all in-memory artifacts, typically at the end of a workflow.
   */
  clearArtifacts() {
    this.artifacts.clear();
    logger.info('üóëÔ∏è [ARTIFACT] All in-memory artifacts have been cleared.');
  }

  /**
   * Save a document and then shard it.
   * @param {string} documentContent - The content of the document.
   * @param {string} documentType - The type of document ('prd' or 'architecture').
   * @param {string} activeAgentId - The ID of the agent performing the action.
   * @returns {Object} An object containing the paths to the main document and the sharded files.
   */
  async shardAndSaveDocument(documentContent, documentType, activeAgentId) {
    const mainDocPath = await this.saveDocument(documentContent, documentType, activeAgentId);
    const shardingResult = await this.engine.shardingManager.shardDocument(documentContent, documentType);

    return { mainDocPath, shardingResult };
  }
}

module.exports = { ArtifactManager };
