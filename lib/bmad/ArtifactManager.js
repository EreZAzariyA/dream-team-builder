/**
 * BMAD Artifact Manager
 * 
 * Manages the lifecycle of documents and other artifacts generated by agents.
 * This system is a key part of Phase 2, ensuring that the document-driven
 * workflow is correctly implemented.
 * 
 * Key Features:
 * - Handles saving and loading of generated documents.
 * - Enforces agent permissions for document access (TODO).
 * - Manages artifact storage paths based on core-config.yaml.
 * - Prepares artifacts for document sharding (Phase 3).
 */

const fs = require('fs').promises;
const path = require('path');
const { validateFilePath, ensureDirectoryExists } = require('../utils/fileValidator');
import logger from '../utils/logger.js';

class ArtifactManager {
  constructor(configurationManager, agentActivationEngine) {
    this.configManager = configurationManager;
    this.agentEngine = agentActivationEngine;
    this.artifacts = new Map(); // In-memory store for artifacts during a workflow
    this.initialized = false;
  }

  async initialize(configurationManager, agentActivationEngine) {
    this.configManager = configurationManager;
    this.agentEngine = agentActivationEngine;
    this.initialized = true;
    logger.info("ArtifactManager initialized");
  }

  /**
   * Save a document to the filesystem.
   * @param {string} documentContent - The content of the document.
   * @param {string} documentType - The type of document (e.g., 'prd', 'architecture').
   * @param {string} activeAgentId - The ID of the agent saving the document.
   * @returns {string} The path to the saved document.
   */
  async saveDocument(documentContent, documentType, activeAgentId) {
    if (!this.agentEngine.canAgentEditSection(activeAgentId, documentType)) {
      logger.warn(`[ARTIFACT] Agent ${activeAgentId} does not have permission to save document type: ${documentType}`);
      throw new Error(`Agent ${activeAgentId} does not have permission to save document type: ${documentType}`);
    }

    const docPath = this.getDocumentPath(documentType);
    logger.info(`üìÑ [ARTIFACT] Saving document of type '${documentType}' to: ${docPath}`);

    try {
      await ensureDirectoryExists(path.dirname(docPath));
      await fs.writeFile(docPath, documentContent, 'utf8');
      
      const artifact = { 
        type: documentType, 
        path: docPath, 
        content: documentContent,
        createdBy: activeAgentId,
        createdAt: new Date().toISOString(),
      };
      this.artifacts.set(documentType, artifact);

      logger.info(`‚úÖ [ARTIFACT] Successfully saved document: ${docPath}`);
      return docPath;

    } catch (error) {
      logger.error(`‚ùå [ARTIFACT] Failed to save document ${docPath}:`, error.message);
      throw new Error(`Failed to save document: ${error.message}`);
    }
  }

  /**
   * Load a document from the filesystem.
   * @param {string} documentType - The type of document to load.
   * @param {string} activeAgentId - The ID of the agent loading the document.
   * @returns {Object} The loaded artifact object.
   */
  async loadDocument(documentType, activeAgentId) {
    if (!this.agentEngine.canAgentViewSection(activeAgentId, documentType)) {
      logger.warn(`[ARTIFACT] Agent ${activeAgentId} does not have permission to load document type: ${documentType}`);
      throw new Error(`Agent ${activeAgentId} does not have permission to load document type: ${documentType}`);
    }
    if (!this.agentEngine.canAgentViewSection(activeAgentId, documentType)) {
      logger.warn(`[ARTIFACT] Agent ${activeAgentId} does not have permission to load document type: ${documentType}`);
      throw new Error(`Agent ${activeAgentId} does not have permission to load document type: ${documentType}`);
    }

    if (this.artifacts.has(documentType)) {
      return this.artifacts.get(documentType);
    }

    const docPath = this.getDocumentPath(documentType);
    logger.info(`üìÑ [ARTIFACT] Loading document of type '${documentType}' from: ${docPath}`);

    try {
      validateFilePath(docPath);
      const content = await fs.readFile(docPath, 'utf8');
      
      const artifact = { 
        type: documentType, 
        path: docPath, 
        content: content,
        loadedBy: activeAgentId,
        loadedAt: new Date().toISOString(),
      };
      this.artifacts.set(documentType, artifact);

      logger.info(`‚úÖ [ARTIFACT] Successfully loaded document: ${docPath}`);
      return artifact;

    } catch (error) {
      logger.error(`‚ùå [ARTIFACT] Failed to load document ${docPath}:`, error.message);
      // It might not exist yet, which is not always a critical error.
      return null;
    }
  }

  /**
   * Get the filesystem path for a given document type.
   * @param {string} documentType - The type of document.
   * @returns {string} The absolute path for the document.
   */
  getDocumentPath(documentType) {
    let relativePath;
    switch (documentType) {
      case 'prd':
        relativePath = this.configManager.get('prd.prdFile');
        break;
      case 'architecture':
        relativePath = this.configManager.get('architecture.architectureFile');
        break;
      // Add other document types here as needed
      default:
        // For stories or other dynamic artifacts
        const storyLocation = this.configManager.get('devStoryLocation');
        relativePath = path.join(storyLocation, `${documentType}.md`);
        break;
    }

    if (!relativePath) {
      throw new Error(`No path configured for document type: ${documentType}`);
    }

    return this.configManager.getAbsolutePath(relativePath);
  }

  async getWorkflowArtifacts(workflowId) {
    // For now, we'll just return the in-memory artifacts.
    // In the future, this could be expanded to retrieve artifacts from a database or other storage.
    return Array.from(this.artifacts.values());
  }

  async saveWorkflowArtifacts(workflowId, artifacts) {
    // For now, just return the artifacts as they're already saved during workflow execution
    // In the future, this could persist artifacts to a database or permanent storage
    logger.info(`üì¶ [ARTIFACT] Saving ${artifacts.length} workflow artifacts for workflow ${workflowId}`);
    return artifacts;
  }

  async getArtifactContent(workflowId, filename) {
    const artifact = Array.from(this.artifacts.values()).find(a => a.path.endsWith(filename));
    if (artifact) {
      return artifact.content;
    }
    return null;
  }

  /**
   * Get an artifact from the in-memory store.
   * @param {string} artifactType - The type of artifact to retrieve.
   * @returns {Object | undefined} The artifact object.
   */
  getArtifact(artifactType) {
    return this.artifacts.get(artifactType);
  }

  /**
   * Clear all in-memory artifacts, typically at the end of a workflow.
   */
  clearArtifacts() {
    this.artifacts.clear();
    logger.info('üóëÔ∏è [ARTIFACT] All in-memory artifacts have been cleared.');
  }

  /**
   * Save a document and then shard it.
   * @param {string} documentContent - The content of the document.
   * @param {string} documentType - The type of document ('prd' or 'architecture').
   * @param {string} activeAgentId - The ID of the agent performing the action.
   * @returns {Object} An object containing the paths to the main document and the sharded files.
   */
  async shardAndSaveDocument(documentContent, documentType, activeAgentId) {
    const mainDocPath = await this.saveDocument(documentContent, documentType, activeAgentId);
    const shardingResult = await this.engine.shardingManager.shardDocument(documentContent, documentType);

    return { mainDocPath, shardingResult };
  }
}

module.exports = { ArtifactManager };
